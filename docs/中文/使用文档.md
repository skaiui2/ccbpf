## 使用示例

这里是一些测试demo，可以作为编写的使用示例。

基本运算：

```c
int hook(void *ctx)
{
    int a;
    int b;
    int c;
    int arr[4];

    a = 3;
    b = 4;
    c = a + b * 2;

    arr[1] = c;
    a = arr[1];

    if (a < b && c == 10) {
        c = c - 1;
    }

    if (a > b || !(c == 10)) {
        c = c + 1;
    }

    if (!(a < b) && !(c != 10)) {
        c = c + 2;
    }
    return 0;
}
```

map使用及更新,其中的count用来统计捕获了多少个udp数据包：

```c
struct udp_hdr {
    unsigned int sport;
    unsigned int dport;
};


int hook(void *ctx)
{
    struct udp_hdr *uh;
    unsigned int key;
    unsigned int count;
    uh = (struct udp_hdr *)ctx;

    key = ntohs(uh->sport);
    count = map_lookup(0, key);

    count = count + 1;
    map_update(0, key, count);

    print(count);

    return 0;
}
```

测试demo：

```c
struct udp_hdr {
    unsigned short sport;
    unsigned short dport;
};

int hook(void *ctx)
{
    unsigned int x;
    unsigned int y;
    unsigned int key;
    unsigned int val;
    struct udp_hdr *uh;

    uh = (struct udp_hdr *)&ctx[0];
    x = ntohs(uh->sport);
    print(x);
    y = ntohs(uh->dport);
    print(y);

    key = x;
    val = y;

    map_update(0, key, val);

    val = map_lookup(0, key);
    print(val);

    print(map_lookup(0, 9999)); 
    map_update(0, 1, 11);
    map_update(0, 2, 22);
    map_update(0, 3, 33);
    print(map_lookup(0, 1));
    print(map_lookup(0, 2));
    print(map_lookup(0, 3));

    return x + y;
}
```

print只有两个功能，只能打印字符串或者数字,

但是，将这两个功能组合起来，足已实现任何解析打印：

```c
struct udp_hdr {
    unsigned short sport;
    unsigned short dport;
};

int hook(void *ctx)
{
    struct udp_hdr *uh;
    unsigned int sport; 
    unsigned int dport; 
    uh = (struct udp_hdr *)ctx;
    sport = ntohs(uh->sport);
    dport = ntohs(uh->dport);

    print("UDP ");
    print("sport=");
    print(sport);
    print(" dport=");
    print(dport);
    print("\n");

    return 0;
}
```

